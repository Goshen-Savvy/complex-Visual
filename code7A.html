<title>Crossfilter with d3.csv</title>
<script src="https://d3js.org/d3.v6.min.js"></script>
<script src="crossfilter.js"></script>
<script src="crawler.js"></script>
<script src="crawllayout.js"></script>

<script>
    let packageNames = [
        "ext_26_1_L_A",
        "ext_26_1_L_D",
        "ext_26_1_R_B",
        "ext_26_1_R_C",
        "ext_26_2_L_A",
        "ext_26_2_L_D",
        "ext_26_2_R_B",
        "ext_26_2_R_C",

    ];
    // listing in bash:
    // for dird in `ls -R -1d packages/*`; do echo -n $dird/; ls $dird | head -1; done
    // OR
    // for dird in `ls -R -1d packages/*`; do echo \"$dird/`ls $dird | head -1`\",; done
    let dataFiles = [
        "packages/ext_26_1_L_A/ext_26_1_L_A20200830T040915.csv",
        "packages/ext_26_1_L_D/ext_26_1_L_D20200830T040915.csv",
        "packages/ext_26_1_R_B/ext_26_1_R_B20200830T040914.csv",
        "packages/ext_26_1_R_C/ext_26_1_R_C20200830T040914.csv",
        "packages/ext_26_2_L_A/ext_26_2_L_A20200830T040911.csv",
        "packages/ext_26_2_L_D/ext_26_2_L_D20200830T040911.csv",
        "packages/ext_26_2_R_B/ext_26_2_R_B20200830T040912.csv",
        "packages/ext_26_2_R_C/ext_26_2_R_C20200830T040912.csv",
    ];

    var numerics = ["magnitude", "raw_magnitude", "amplitude"];
    function isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }
    let epaochParse = d3.timeParse("%j days %H:%M:%s.%L000000");
    function dataconverter(d) {
        // coerce numbers to floats, empty strings to null
        numerics.forEach(function (dim) {
            d[dim] = isNumber(d[dim]) ? parseFloat(d[dim]) : null;
        })
        // d.EpochDate = epochParse(d.package_time) // for a date object
        DHMS = d.package_time.split(/ days |:/).map(parseFloat); // array of time elements
        d.ptime_ms = ((((DHMS[0] * 24) + DHMS[1]) * 60 + DHMS[2]) * 60 + DHMS[3]) * 1000;
        d.ptime_DMHS = DHMS
        return d;
    }
    var c1, streamIter;
    let allPromises = dataFiles.map(fn => d3.csv(fn, dataconverter))
    Promise.all(allPromises).then(allData => {
        // file data now loaded

        // construct the crossfilters
        let threadCF = allData.slice(0,2).map(() => crossfilter()) // slice to 2 for testing

        // create stream simulator from allData
        // set up a generator function to simulate a data stream from the read data
        // 
        streamIter = (function* (){
            for(let datai=0; datai<allData[0].length;datai++){
            threadCF.forEach( (cf, cfnumber) =>
                     cf.add(allData[cfnumber].slice(datai,datai+1)))
                     yield datai

            }   
        })()
        // button for streaming
        d3.select("body").append("button").text("Simuate streamed value")
            .on("click", () => streamIter.next());

        // our crawler factory. For a 700 wide cralwer, we are going to space them
        // 50 pixels apart there is room for 14 data points.
        let crawlup = crawler([700, 200], 14)

        // svg to draw in
        let svg1 = d3.select("body").append("p").style("margin-left", "50px")
            .append("svg").attr("width", 900).attr("height", "1000") // our svg

        // create and register our crossfilters with the layout
        let tc = tracklayout(crawlup) // tc should not need to know crawlup

        let crawlgs = [] // index associates crawlgs with tc registry. Better ideas for this?
        threadCF.map( (cf, i) => {
            crawlgs[i] =  crawlup(svg1)
            tc.register(cf, crawlgs[i]) // Get rid of 2nd argument - tc should not need this info
            cfcrawlsetup( crawlgs[i], cf, i * 250) // should initializing be in the tc?

        })

       /* tc.registry.forEach((cf,i) => {
            cfcrawlsetup( crawlgs[i], cf, i)
        })
        */
        tc.onNewData( () => {
            console.log("[]==>" , tc.datalength)
            // all cf's have advanced
            // do the drawing here
            tc.registry.forEach( (cf, i) => {
                console.log("redraw the cf", i) 
                reDraw( cf, crawlgs[i], tc.datalength, 14 )
            })
            crawlup.crawlto(tc.datalength -1)
        })
        
        
        c1 = crawlup;
    })

    let yscale = d3.scaleLinear()
        .domain([300,600]) // good for amplitude?
        .range([0, 200])
    function reDraw( cf, selection, hidrawi, iwidth){
        // draw into the given d3 selection between given indicies
        // of cf. Basically a draw with the limits given.
        console.log("redraw", cf, selection, hidrawi, iwidth )
        let lowdrawi = Math.max(0,hidrawi-iwidth)
        let s = selection.select("#ampcircles")
            .selectAll("circle")
            .data(cf.all()) // keyed by cf index
            .enter()
            .filter((d,i) => i < hidrawi && i >= lowdrawi)
            .append("circle")
            .attr("fill", "red")
            .attr("cx", (d, i) => d.ptime_ms / 200 * 50) // should depend on date
            .attr("cy", d => yscale(d.amplitude))
            .attr("r", 5)
            //.each(console.log)
        //sconsole.log("filtered", s.size(), s)
    }
     function cfcrawlsetup(crawlg, cf, yoffset = 100, xoffset = 100) {
        crawlg.transform(`translate(${xoffset},${yoffset})`)
        crawlg.crawlRect.attr("fill", "lightgrey").style("display", "block")

        // we need a layer that put data points into the crawlgroup, based on
        // 
        // figure out scaling for amplitude



        crawlg.append("g").attr("id", "ampcircles")
            .selectAll("circle")
            .data(cf.all())
            .enter().append("circle")
            .attr("fill", "red")
            .attr("cx", (d, i) => d.ptime_ms / 200 * 50) // should depend on date
            .attr("cy", d => yscale(d.amplitude))
            .attr("r", 5)

        // simulated x axis
        let ticks = crawlg.append("g").attr("id", "ampticks")
            .attr("transform", "translate(0,180)")
            .attr("fill", "none")
            .attr("font-size", 10)
            .attr("font-family", "sans-serif")
            .attr("text-anchor", "middle")
            .selectAll(".ticks")
            .data(cf.all())
            .enter().append("g")
            .attr("class", "ticks")
            .attr("transform", (d, i) => `translate(${d.ptime_ms / 200 * 50},0)`)
        ticks
            .append("line")
            .attr("y2", 6)
            .attr("stroke", "currentColor")
        ticks
            .append("text")
            .attr("fill", "currentColor")
            .attr("y", 9)
            .attr("dy", "0.71em")
            .text(d => d.ptime_ms)


        // should not use d3 axis because the x-extent of the range is not fixed
        //let xCount = cf.all().length
        //let xMax = cf.all()[xCount - 1].ptime_ms
        //crawlg.append("g").attr("transform", "translate(0,180)")
        //    .call(d3.axisBottom().scale(d3.scaleLinear()
        //        .range([0, xMax / 200 * 50]).domain([0, xMax])).ticks(xCount))
    }

    function cfRedraw(crawlg, cf) {
        let cselect = crawlg.select("#ampcircles")
            .selectAll("circle")
            // .data(cf.allFiltered) 
            // recode this.. bad dependency that data set has not changed
            .attr("fill", (d, i) => cf.isElementFiltered(i) ? "red" : "blue")

    }
</script>
<style>
    body {
        font-size: 13px;
        font-family: sans-serif;
    }
</style>